'''Module reading tobii 4c eyetracker data from udp data stream, allowing in-expyvr position calibration and making available current eye or head position data@author: Christian Pfeiffer@since: September 2018'''from os import pathfrom time import sleepimport csv, re, globimport threading, socketimport numpy as npimport math as mtfrom planar import Affinefrom planar import Vec2from datetime import datetimefrom pyglet.gl import *from pyglet import imagefrom pyglet.clock import _default_time_function as time#pylnco modulesfrom controller import getPathFromStringfrom display.tools import *from abstract.AbstractClasses import DrawableModulefrom abstract.AbstractClasses import DrawableHUDModulefrom abstract.AbstractClasses import DrawableHUDSourceModule        class ModuleMain(DrawableHUDSourceModule):    defaultInitConf = {        'name': 'tobii',        'logToCSV': True,        'calibrationMode': False,        'calibrationFile': "$EXPYVRROOT$/lncocomponents/tobii/calibration.csv",    }        defaultRunConf = {        'showEye': True,        'showHead': True,    }        confDescription = [        ('name', 'str', ""),        ('logToCSV', 'bool', ""),        ('calibrationMode', 'bool', ""),        ('calibrationFile', 'str', "..."),        ('showEye', 'bool', ""),        ('showHead', 'bool', ""),    ]        def __init__(self, controller, initConfig=None, runConfigs=None):        DrawableHUDSourceModule.__init__(self, controller, initConfig, runConfigs)        self.label = None        self.keylist = ['e', 'h', 'space']        self.keyliststr = ''        for i in range(len(self.keylist)):            self.keyliststr += self.keylist[i]            self.keyliststr += ' '                    self.trial = 0                self.eyeOrHead = 1                self.screenSize = []        self.text = ''        self.commandPos = []        self.showCommand = False        self.showCenterCross = False        self.showFourCross = False                if self.activeConf['showEye']:            self.showGaze = True        else:            self.showGaze = False                    if self.activeConf['showHead']:            self.showHead = True        else:            self.showHead = False                        self.crossPos = [0.5, 0.5]                self.gazeHeadPos = [0.5, 0.5, 0.5, 0.5]                self.bufferSize = [2, 2, 4, 4]        self.gazeHeadBuffer = []        for i in range(len(self.bufferSize)):            self.gazeHeadBuffer.append(CircularBuffer(self.bufferSize[i]))                    self.inputVals = []        self.inputMsg = ''        self.regexp = re.compile("[p][]*[(]*([-+]?\d*\.\d*)[,][ ]*([-+]?\d*\.\d*)[,][ ]*([-+]?\d*\.\d*)[,][ ]*([-+]?\d*\.\d*)[,][ ]*([-+]?\d*\.\d*)[)]")        self.currentKey = []        self.calibrationVector = []        if self.initConf['calibrationMode']:            print "calibration mode"            self.calibrationVector = [0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0]        else:            try:                print "Loading Calibration File"                reader = csv.reader(open(getPathFromString(self.initConf['calibrationFile'])), delimiter=',')                for line in reader:                      for str in line:                        self.calibrationVector.append(float(str))            except:                self.calibrationVector = [0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0]                print "No Calibration File Found"                    self.calib = [[],[],[],[]]        self.updateTime = 0.01 # 200Hz        self.points = []        self.x = []        self.y = []        self.pointcount = 0        #counter variable for the different processing for calibration        self.step = 0        # init log        self.starttime = time()        self.thread = None                #logging        self.logActive = self.initConf['logToCSV']        if self.logActive:            now = datetime.today()            self.csvLogger = csv.writer(open(path.join(self.controller.gLogger.Path, now.strftime('%y%m%d%H%M%S_') + self.initConf['name'] +  '.csv') , 'w'), lineterminator = '\n')            hdr = ['expTime','trial','eyeX','eyeY','headX','headY']            self.csvLogger.writerow(hdr)                                        self.screenSize = []        self.offset = []        #scaling factor relative to total screen size to move fixation points away from the outside inward toward center        self.offsetFactor = 0.05                                    def average(self, lst):        return sum(lst) / len(lst)                        # step_9: end current routine    def endRoutine(self):        self.text = "Writing Calibration output.."        #write calibration output to csv...        self.showCenterCross = False        self.showGaze = False        self.showHead = False        self.controller.endCurrentRoutine()                    # when key is pressed update the self.currentKey variable    def onKeyPress(self, keypressed=None):        self.currentKey = keypressed        print self.currentKey, " press"                            # when key is released empty self.currentKey variable    def onKeyRelease(self, keypressed=None):        print self.currentKey, " release"                    # what to render to the screen    def draw(self, window_width, window_height, eye=-1):        DrawableHUDSourceModule.draw(self, window_width, window_height)        self.screenSize = [float(window_width), float(window_height)]        self.offset = [float(window_width)*self.offsetFactor, float(window_height)*self.offsetFactor]                font =40                self.label = pyglet.text.Label(text=self.text,                                       color=(255, 255, 255, 255),                                       font_name='Lucida Console',                                       font_size=18,                                       anchor_x='center', anchor_y='center',                                       width=600, multiline=False,                                       x=self.screenSize[0]*0.5, y=self.screenSize[1]*0.55)        self.label.draw()         if self.showCenterCross:            self.label = pyglet.text.Label(text='+',                                           color=(255, 255, 255, 255),                                           font_name='Lucida Console',                                           font_size=font,                                           anchor_x='center', anchor_y='center',                                           width=1, multiline=False,                                           x=self.crossPos[0], y=self.crossPos[1])            self.label.draw()                     if self.showFourCross:            for i in range(len(self.points)):                self.label = pyglet.text.Label(text='+',                                           color=(255, 255, 255, 255),                                           font_name='Lucida Console',                                           font_size=font,                                           anchor_x='center', anchor_y='center',                                           width=1, multiline=False,                                           x=self.points[i][0], y=self.points[i][1])                self.label.draw()                     if self.showGaze and len(self.gazeHeadPos)==4:            self.label = pyglet.text.Label(text='o',                                           color=(255, 0, 0, 255),                                           font_name='Lucida Console',                                           font_size=font,                                           anchor_x='center', anchor_y='center',                                           width=1, multiline=False,                                           x=self.gazeHeadPos[0]*self.screenSize[0], y=self.gazeHeadPos[1]*self.screenSize[1])            self.label.draw()                     if self.showHead and len(self.gazeHeadPos)==4:            self.label = pyglet.text.Label(text='o',                                           color=(255, 0, 255, 255),                                           font_name='Lucida Console',                                           font_size=font,                                           anchor_x='center', anchor_y='center',                                           width=1, multiline=False,                                           x=self.gazeHeadPos[2]*self.screenSize[0], y=self.gazeHeadPos[3]*self.screenSize[1])            self.label.draw()         if self.showCommand and len(self.commandPos)==2:              self.label = pyglet.text.Label(text='o',                                           color=(255, 0, 0, 255),                                           font_name='Lucida Console',                                           font_size=font,                                           anchor_x='center', anchor_y='center',                                           width=1, multiline=False,                                           x=self.commandPos[0]*self.screenSize[0], y=self.commandPos[1]*self.screenSize[1])            self.label.draw()                         self.label = pyglet.text.Label(text='Move Cursor to Start Position',                                           color=(255, 255, 255, 255),                                           font_name='Lucida Console',                                           font_size=30,                                           anchor_x='center', anchor_y='center',                                           width=1, multiline=False,                                           x=0.5*self.screenSize[0], y=0.5*self.screenSize[1])            self.label.draw()     def start(self, dt=0, duration=-1, configName=None):        DrawableHUDSourceModule.start(self, dt, duration, configName)        # start update        pyglet.clock.schedule_interval(self.update, self.updateTime)        self.controller.registerKeyboardAction(self.keyliststr, self.onKeyPress, self.onKeyRelease)        self.stepTime = time()        self.trial += 1                       # stop module    def stop(self, dt=0):        DrawableHUDSourceModule.stop(self, dt)        pyglet.clock.unschedule(self.update)        self.controller.unregisterKeyboardAction(self.keyliststr, self.onKeyPress, self.onKeyRelease)            # cleanup module    def cleanup(self):         DrawableHUDSourceModule.cleanup(self)        print "cleanup"            def update(self, dt):                #set the points during first iteration, not before, because screen size is needed, only available from draw()        if len(self.points) == 0:            self.points = [   [                    self.offset[0], self.screenSize[1]/2              ], #left                              [ self.screenSize[0]-self.offset[0], self.screenSize[1]/2              ], #right                              [ self.screenSize[0]/2             ,                    self.offset[1] ], #down                              [ self.screenSize[0]/2             , self.screenSize[1]-self.offset[1] ] ] #up                                      #update input values (float) from udp message (string)        self.updateInputVals()                #==================#        # Calibration Mode #        #==================#        if self.initConf['calibrationMode']:                    currTime = time()            #======#            # menu #            #======#            if self.step == 0:                self.text = "Selection Menu: [" + self.keylist[0].upper() + "] = EYES, [" + self.keylist[1].upper() + "] = HEAD, [" + self.keylist[2].upper() + "] = EXIT."                self.crossPos = [self.screenSize[0] * 0.5, self.screenSize[1] * 0.5, ]                self.showCenterCross = True                self.showGaze = False                self.showHead = False                self.showFourCross = False                self.pointCount = 0                #if any of the possible keys was pressed                if len(self.currentKey) > 0:                    #if the first two keys, for calibration, were pressed                    if (self.currentKey.lower() == self.keylist[0].lower()) or (self.currentKey.lower() == self.keylist[1].lower()):                        self.step = 1                        #if the eye calibration was selected                        if self.currentKey.lower() == self.keylist[0].lower():                            self.eyeOrHead = 1                        #if the head calibration was selected                        else:                            self.eyeOrHead = 2                        self.currentKey = []                        self.stepTime = currTime                    #if the exit key was selected                    elif self.currentKey.lower() == self.keylist[2].lower():                        self.step = 9                        self.currentKey = []            #=============#            # calibration #            #=============#            elif self.step == 1:                #if eye calibration was selected                if self.eyeOrHead == 1:                    self.text = "EYE CALIBRATION: Fixate on the Cross"                #if head calibration was selected                else:                    self.text = "HEAD CALIBRATION: Turn your Head to the Cross"                #update data reading from eyetracker                self.updateGazeHeadPos()                self.crossPos = self.points[self.pointCount]                self.showCenterCross = True                self.showGaze = False                self.showHead = False                self.showFourCross = False                if (currTime-self.stepTime > 2.0) and (currTime-self.stepTime <= 4.0):                    if self.eyeOrHead == 1:                        self.x.append(self.inputVals[0])                        self.y.append(self.inputVals[1])                    else:                        self.x.append(self.inputVals[2])                        self.y.append(self.inputVals[3])                elif (currTime-self.stepTime > 4.0):                    self.calib[self.pointCount] = [self.average(self.x), self.average(self.y)]                    self.x = []                    self.y = []                    self.pointCount += 1                    self.stepTime = currTime                    if self.pointCount > len(self.points)-1:                        self.updateCalibrationVector()                        self.pointCount = 0                        self.stepTime = currTime                        self.step = 2            #==============#            # visual check #            #==============#            elif self.step == 2:                self.text = "Check Calibration Results, hit [" + self.keylist[2].upper() + "] to continue."                self.updateGazeHeadPos()                self.crossPos = [self.screenSize[0] * 0.5, self.screenSize[1] * 0.5, ]                self.showGaze = True                self.showHead = True                self.showFourCross = True                self.showCenterCross = True                if self.eyeOrHead == 1:                    self.showGaze = True                else:                    self.showHead = True                if len(self.currentKey) > 0:                    #if key_1 pressed exit                    if self.currentKey.lower() == self.keylist[2].lower():                        self.step = 0                        self.currentKey = []                        self.stepTime = currTime                        self.writeCalibrationOutput()            else:                self.text = "Closing Down."                if (currTime-self.stepTime > 2.0):                    self.endRoutine()                            #======================#        # Not Calibration Mode #        #======================#        else:            self.updateGazeHeadPos()            self.showFourCross = False            self.showCenterCross = False                #logging        if self.logActive:                        line = [self.controller.gTimeManager.experimentTime(),                    self.trial]                        if len(self.gazeHeadPos) == 4:                line.append(self.gazeHeadPos[0])                line.append(self.gazeHeadPos[1])                line.append(self.gazeHeadPos[2])                line.append(self.gazeHeadPos[3])            else:                line.append('NaN')                line.append('NaN')                line.append('NaN')                line.append('NaN')            self.csvLogger.writerow(line)    def updateCalibrationVector(self):        if len(self.calib) == 4:            self.calibrationVector[((self.eyeOrHead-1)*4) + 0] = self.average([self.calib[0][0], self.calib[0][0]])            self.calibrationVector[((self.eyeOrHead-1)*4) + 1] = self.average([self.calib[1][0], self.calib[1][0]])            self.calibrationVector[((self.eyeOrHead-1)*4) + 2] = self.average([self.calib[2][1], self.calib[2][1]])            self.calibrationVector[((self.eyeOrHead-1)*4) + 3] = self.average([self.calib[3][1], self.calib[3][1]])                                                                def updateInputVals(self):        if len(self.inputMsg)>0:            vals = self.regexp.match(self.inputMsg)            if vals is not None:                self.inputVals = [float(vals.group(1)), float(vals.group(2)),float(vals.group(3)), float(vals.group(4))]      #apply calibration (calibration vector) values to the raw input from eyetracker (inputVals)    def updateGazeHeadPos(self):            if len(self.inputVals)== 4 and len(self.calibrationVector) == 8:            #eye position X            self.gazeHeadBuffer[0].addVal( ( ( (self.inputVals[0] - self.calibrationVector[0]) / (self.calibrationVector[1] - self.calibrationVector[0]) ) * (1.0 - 2.0 * self.offsetFactor) ) + (self.offsetFactor) )            #eye position Y            self.gazeHeadBuffer[1].addVal( ( ( (self.inputVals[1] - self.calibrationVector[2]) / (self.calibrationVector[3] - self.calibrationVector[2]) ) * (1.0 - 2.0 * self.offsetFactor) ) + (self.offsetFactor) )            #head position X            self.gazeHeadBuffer[2].addVal( ( ( (self.inputVals[2] - self.calibrationVector[4]) / (self.calibrationVector[5] - self.calibrationVector[4]) ) * (1.0 - 2.0 * self.offsetFactor) ) + (self.offsetFactor) )            #head position Y            self.gazeHeadBuffer[3].addVal( ( ( (self.inputVals[3] - self.calibrationVector[6]) / (self.calibrationVector[7] - self.calibrationVector[6]) ) * (1.0 - 2.0 * self.offsetFactor) ) + (self.offsetFactor) )                        for i in range(4):                self.gazeHeadPos[i] = self.gazeHeadBuffer[i].getAverage()        else:            self.gazeHeadPos = self.inputVals                def writeCalibrationOutput(self):        print "write ouput to file"        self.csvLogger = csv.writer(open(getPathFromString(self.initConf['calibrationFile']), 'w'), lineterminator = '\n')        self.csvLogger.writerow(self.calibrationVector)                class CircularBuffer(object):    def __init__(self, size):        """initialization"""        self.index= 0        self.size= size        self.data = []    def addVal(self, value):        """append an element"""        if len(self.data) >= self.size:            self.data[self.index]= value            self.index= (self.index + 1) % self.size            if self.index > self.size:                self.index = 0        else:            self.data.append(value)                def getVal(self, key):        """get element by index like a regular array"""        return(self.data[key])    def getAll(self):        """return a list of all the elements"""        return(self._data)            def getAverage(self):        """return an average of all elements"""        return(sum(self.data) / len(self.data))                        